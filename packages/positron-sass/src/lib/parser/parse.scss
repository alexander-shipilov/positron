@import "../core";
@import "../map/map-map-values";
@import "../map/map-get-deep";
@import "../list/list-map";
@import "../string/str-split";
@import "../types/validate";

$parse-identifier: unique-id();
$parse-rule: unique-id();

$and: and;
$or: or;

@function rule($rule) {
    @return null;
}


$rules: (
    but: "not",

    expect: $parse-identifier (to: "should"),
    should: expr,

    expr: (
        --and: expr $and expr,
        --or: expr $or expr,
        --expr: to
    ),

    main: (
        --expect: expect,
        --should: should
    ),

    to: (
        be: (
            a: (
                bool: null,
                boolean: null,
                color: null,
                function: null,
                list: "?that",
                map: "?that",
                number: null,
                string: null,
            ),
            null: null,
        ),
        deep: (
            equal: "to.equal",
            include: "to.include"
        ),
        equal: $parse-identifier,
        have: (
        ),
        include: $parse-identifier,
    ),
    that: (
        includes: "to.include"
    )
);

@function --get-rule($rules, $rule-name) {
    $rule: map-get-deep($rules, str-split($rule-name, "."));

    @if ($rule == null) {
        $error: throw("Invalid rule #{ $rule-name }");
    }

    @return $rule;
}

@function --get-rule-for-input($rules, $input, $index) {
    $rule: --get-rule($rules, $input);

    @if ($rule == null) {
        $error: throw("Invalid input #{ $input } at #{ $index }. Expected one of #{ to-string(map-keys($rules)) }");
    }

    @return $rule;
}

@function --parse-string-rule-at($rules, $rule, $input, $index) {
    @return --parse-rule-at($rules, --get-rule-for-input($rules, $input, $index), $input, $index);
}

@function --parse-rule-at($rules, $rule, $inputs, $index) {
    $type: type-of($rule);
    $input: nth($inputs, $index);
    $token: null;

    @if($input) {
        $token: $input;
    } @else if ($type == "string") {
        $token: --parse-string-rule-at($rules, $rule, $input, $index);
    } @else if ($type == "list") {

    } @else if ($type == "map") {

    } @else if($type == "null") {


    }

    @return $token;
}

@function --parse-rules($rule, $inputs, $rules) {
    $parse-identifiers: ();

    @if (length($inputs)) {
        @for $index from 1 through $inputs {
            $parse-identifier: --parse-rule-at($rule, $inputs, $index, $rules);

            @if ($parse-identifier) {
                $parse-identifiers: append($parse-identifiers, $parse-identifier);
            }
        }
    }

    @return $parse-identifiers;
}

@function parse($inputs, $rules, $start-rule: null) {
    $valid-args: validate((inputs: list $inputs, rules: map $rules, start-rule: optional(string) $start-rule));

    @if ($valid-args) {
        $rule: if($start-rule != null, --get-rule($rules, $start-rule), $rules);

        @return --parse-rules($rule, $inputs, $rules);
    }

    @return null;
}

